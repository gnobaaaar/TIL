# 프로세스와 쓰레드

## 프로세스
> 실행중인 프로그램

프로그램 진행 상태를 완전하게 나타내는 자료구조 -> 프로세스 디스크립터
`Process Descriptor` : 한 프로세스와 관련된 모든 정보를 담고 있는 task_struct 자료구조

![[Pasted image 20221013205033.png]]

## 쓰레드
프로세스 내의 실행 흐름(프로세스 당 1개 이상의 쓰레드 존재)
리눅스 - 경량 프로세스 -> 쓰레드 단위로 스케줄링
커널에서는 동일하게 취급

쓰레드는 **주소공간, 열린 파일 등 여러 자원을 공유 가능**





# 프로세스의 주요 구성 요소
## PID
커널은 각 프로세스에 고유한 ID를 부여 -> 보통 순서대로 배정


## PPID (parent process ID)
리눅스는 새 프로그램을 시작X
기존 프로세스를 복제하고 프로그램 교체
- 기존 프로세스는 새로운 프로세스를 생성, 자신을 복제
- 복제된 프로세스는 현재 실행중인 프로그램을 교체
PPID는 그 프로세스를 복제한 부모의 PID


## Niceness
프로세스 스케줄링의 우선순위를 결정
우선순위높다 = CPU 사용시간이 길어진다
**Nice** : -20 ~ +19 (작을 수록 불친절=우선순위높다)

```
nice n 5 [command]
sudo renice -5 -p [process id]
sudo renice 5 -u [username or UID]
```

대부분의 경우 기본값을 사용




# 프로세스 생성

## 신규 프로세스 생성
![[Pasted image 20221013210311.png]]

1. fork 시스템 콜로 자신을 복제 -> 서로 다른 값을 반환
2. parent (자식 pid를 리턴) child (0을 리턴)
3.  자식은 새 프로그램의 실행을 위해 exec 계열의 함수를 호출
	현재 실행되고 있는 프로그램을 다른 것으로 교체


![[Pasted image 20221013210451.png]]




## 프로세스 상태
Task_Running
- 프로세스가 실행 가능한 상태
- 현재 실행중 또는 실행 큐에 실행 대기 상태

Task_Interruptible
- 특정 조건을 기다리며 프로세스가 대기(sleep) 또는 중간(block) 되어있는 상태
- 기다리는 조건이 발생 또는 시그널을 받으면 실행가능 상태로 이동

Task_Uninterruptible
- 위와동일하지만 시그널을 받아도 깨어나지않음
- ex) 프로세스가 다른 방해를 받지않고 반드시 대기해야 하는 경우 -> 세마포어를 잡고 중요한 동작을 하고 있는 경우

Task_Zombie
- 프로세스가 중단된 상태
- 부모 프로세스가 wait 시스템 콜을 호출하지 않은 경우




## 프로세스 상태 모니터링
`ps aux`
실행중인 모든 프로세스에 대한 정보를 표시
- a : 모든 프로세스
- u : 사용자 친화적 출력
- x : 터미널에 없는 프로세스도 표시

![[Pasted image 20221013211522.png]]

`ps lax`
실행 중인 모든 프로세스
UID를 사용자명이 아닌 ID로 표시 -> 조금 더 가볍게 동작
- l : long 형태로 표시

`ps aux | grep -v grep | grep sshd` = `ps aux | grep sshd`
특정 명령에 대한 process 정보를 표시
-v 옵션을 통해 grep 정보를 제거

`ps auxf`
- f : 자식프로세스를 트리 형태로 표시

`top` = `htop`
3초(기본값) 동안 수집한 프로세스 정보를 지속적으로 제공
가장 CPU를 많이 사용하는 프로세스를 위에 배치
화면 상단 -> 요약 정보




## 프로세스 종료
kill [-signal] pid

- 주요 시그널
	- SIGTERM [15] : 실행을 완전히 종료 요청, **프로세스가 시그널 (처리/차단) 가능**
	- SIGKILL [9] : `차단 불가능`, 프로세스를 커널 수준에 종료, 프로세스가 시그널 수신X
	- SIGINT [2] : 터미널에서 ctrl+c 입력시 전송, 프로세스가 시그널 수신(처리/차단) 가능

kill -15 -> kill -9 로 시도 -> 재부팅



## proc 파일 시스템

리눅스 도구들은 커널 정보를 어떻게 사용할까
-> **proc 파일 시스템**
커널이 시스템 정보와 관련한 정보를 노출시키는 pseudo 파일 시스템
-> 실제 파일이 존재X 크기0

커널모드가 아닌 유저모드에서 쉽게 접근가능하게 해준다
프로세스 정보 외에도 커널이 관리하는 다양한 상태정보와 통계값을 제공

ps, top, vmstat 등을 사용
-> 잘 알려지지 않은 정보는 proc정보를 직접 읽어야한다

![[Pasted image 20221017184604.png]]


![[Pasted image 20221017184702.png]]
/sbin/init 프로세스가 실행되어 있는것이 확인 가능





## 주기적인 작업 관리

### 활용 예
새벽 1시마다 보안 관련 도구 실행
백업 및 미러링 -> DB 백업, 리모트 호스트에 디렉토리 단위 복사
배치 작업 수행
- 무거운 배치작업은 많은 서버가 동시에 실행X
- `'sleep rand 9000' && 실행할 커맨드`
시스템 정보를 메일로 전송
로그데이터 관리
- 로그 파일 로테이션
- 일정시간 지난 데이터는 압축, 그 후에는 삭제

### cron
정의된 스케줄에 따라 명령을 실행하는 도구
cron 작업을 수행하는 데몬은 시스템 시작 시 구동되고, 계속 실행된다
cron table 파일 작성

### crontab 관리
`-e` : 편집
`-l` : 리스트 출력
`-r` : crontab 삭제
root 사용자는 다른 사용자의 정보 확인 가능 `crontab -e USER_ID`

![[Pasted image 20221017185229.png]]



## 실습

![[Pasted image 20221017190012.png]]

![[Pasted image 20221017190212.png]]

-> crontab도 이미 구성
- 사용자 정의 cron job
- 시스템 정의 cron job
	- 일, 시간, 주, 월별 주기 작업을 위한 설정 포함
	- 해당 디렉토리에 포함된 스크립트를 실행


`/etc/logrotate.d`
![[Pasted image 20221017190644.png]]


