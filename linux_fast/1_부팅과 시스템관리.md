## 부팅 프로세스

### 부팅 로그
클라우드는 네트워크를 통한 서버 접근 / 클라우드 가상머신 부팅 시 로그 확인은?
-> `dmesg, syslog` 확인
-> 시스템 로그 확인용 콘솔이 제공

물리머신에서는 부팅시 표시된다


### 리눅스 시스템 부팅 순서
1. 바이오스에서 하드웨어 검사 후 부팅 기기 선택 및 파티션 식별
2. 부트로더에서 커널 선택 및 커널 로드
3. 커널 자료구조 초기화 및 시작 서비스 구동

![[Pasted image 20220925014947.png]]

`init process` -> 최초의 유저 레벨 프로세스
등록된 시작 스크립트 -> 네트워크, 볼륨 등


### BIOS vs UEFI
- BIOS
	- 전원이 들어오면 실행되는 최초의 프로그램
	- 바이오스는 마더보드에 연결된 디바이스를 초기화하고 검사(POST)하는 역할을 수행
	- POST=Power On Self Test
	- 부트로더 또는 운영체제를 RAM으로 읽어오는 기능을 수행
- 가상머신에서의 오류 -> stop/start로 다른 호스트로 가상머신이 구동되어 해결된다
	- stop+start != restart -> 동일한 호스트에서 재구동

- BIOS에서 시스템 정보 읽기
	- `dmidecode`
		- DMI 테이블 정보를 사람이 읽을 수 있게 출력해주는 도구
		- `dmidecode -t memory`

- UEFI
	- 좀 더 정형화하고 표준화한 PC펌웨어
	- 2TB 스토리지 지원, 빠른 부팅시간, 주소공간 추가(UI 및 기능개선)
	- 가상환경에서는 Legacy BIOS도 여전히 많이 사용


### 부트로더
- 사용 가능한 커널을 확인 후 로드
- 부팅타임에 사용 가능한 운영체제 선택을 위한 UI 제공

- **GRUB**
	- GRUB2가 주로 사용
	- 설정
		- 커널목록, 부팅 옵션 등
		- 부팅옵션: debug, init=/bin/bash, root=/root/foo, single
		- 일반 텍스트 파일로 설정을 관리
			- `/boot/grub/grub.cfg`
			- `/boot/grub2/grub.cfg`

**운영체제가 구동 전인데 파일시스템을 사용 가능한가?**
-> Grub은 대부분의 파일시스템을 인식한다


**클라우드 환경에서 GRUB을 알아야하나?**
사례 : 가상머신을 사용하던 중 커널 업데이트 중 커널의 손상, SSH 연결X

**해결방법**
https://aws.amazon.com/ko/premiumsupport/knowledge-center/revert-stable-kernel-ec2-reboot/

1. 루트 볼륨에 접근
	- EC2 직렬 콘솔 사용
	- Nitro 기반 인스턴스 유형만 가능

2. 복구 인스턴스 사용
	- (복구용) 별도의 가상머신을 생성 -> 인스턴스의 볼륨을 마운트

-> GRUB 설정의 기본 커널 정보를 변경
다시 마운트 후 부팅을  실행한다

![[Pasted image 20220925024705.png]]


---

## 시작 서비스의 이해
시스템 구동시 최초 실행되는 사용자 레벨 프로세스 -> 각종 스크립트를 실행

- 시작 서비스 위치
	- `/etc/init.d`
- 실행 레벨에 맞게 시작 서비스가 구동
	- rc5 -> `/etc/rc5.d`


### 실행레벨
운영체제가 부팅이후의 머신 상태를 결정
single user -> 파일 시스템 마운트, 네트워크 비활성화, 시스템 관리용 쉘 접근
multi user -> 일반적인 사용자 접근

![[Pasted image 20221005223909.png]]


### init 프로세스 구현
**systemd**
기존 init 프로세스보다 더 넓은 범위의 기능 구현
Red Hat, Debian, Ubuntu에서 기본 init 프로세스로 사용

*시스템 어드민의 관점* -> 유지할 레거시 시스템이 없는 경우, 대부분 환경에서 systemd가 사용



### systemd
- 기존 init 프로세스의 기능을 지원 및 통합
- 동작 모드에 따른 시작 서비스 관리
- **병렬 실행** 및 **종속성 모델 관리**
- 커널 로드 엔트리 관리(journald)
- 네트워크 연결 관리
- 로그인 관리


### unit 파일
systemd의 기본 개체 단위
- service, socket, device ...
- Unit 섹션
	- 기본정보정의
	- Description : 사람이 읽을 수 있는 정보, 레이블로 활용
	- After, Requires, Wants
- Unit 유형 섹션
	- ExecStart : **구동할 절대경로 명령어를 지정(!!)**
	- Restart : 서비스 재시작 여부
- Install 섹션
	- Alias : Unit 을 등록할 때 사용하는 이름(systemctl enable sshd.service)
	- WantedBy : Unit간 종속성을 지정
	
![[Pasted image 20221006223714.png]]



### systemctl
systemd의 관리용 도구
`systemctl list-units --type=service` : active 상태의 모든 서비스
`systemctl list-unit-files --type=service` : active 여부와 관계없이 모든 서비스
= `-t service`

`enable` : 부팅시 자동 활성화
disable
start
stop
restart
`status` : unit의 상태 및 최근 로그 내용 확인
kill pattern : 패턴과 일치하는 유닛에 시그널을 보냄
reboot
`daemon-reload` : unit 파일들과 systemd 설정 정보를 다시 로드

![[Pasted image 20221006224023.png]]




### 실습
1. 실행 중인 서비스 목록 확인
`sudo systemctl list-units -t service`
![[Pasted image 20221011200603.png]]

2. cron 서비스 상태 확인
`sudo systemctl status cron.service`
![[Pasted image 20221011200714.png]]

3. cron 프로세스 강제 종료 및 재시작 확인
```
ps aux | grep cron
sudo kill -9 [CRON_PROCESS_ID]
ps aux | grep cron
```

![[Pasted image 20221011200834.png]]

4. cron 서비스 중단 및 재시작
`sudo systemctl stop cron.service`
`sudo systemctl restart cron.service`

```
Restart=on-failure #kill되면 재시작된다 -> PID 변경
```





## 시스템 재부팅 및 종료
운영 중인 시스템 재부팅은 서비스 중단을 초래
**근본적인 원인을 찾아야한다**
메모리풀, 네트워크 소켓 수 증가 등 -> 재부팅으로 해결X
시작 스크립트 수정, 중요한 설정 변경 -> 재부팅하여 적용을 확인 한다

### 물리 호스트 종료
halt, shutdown(로그인 사용자에게 알림), reboot
```
sudo shutdown -h now
sudo halt -p
sudo reboot
```

### 클라우드 환경 가상머신 종료
위와 동일하나 
콘솔, API 이용은 권장하지 않음 =전원버튼으로 종료와 마찬가지 
인스턴스 종료는 인스턴스를 삭제 -> 복구X
종료 방지 기능을 설정하여 주의한다


### 부팅 실패한 시스템 복구방법
1. 디버깅하지 않고 **백업으로부터 복구**
-> 클라우드 방식

2. **디버깅 모드**로 시스템을 구동하여 복구
단일 사용자모드, 복구모드, 긴급모드
-> 네트워크 사용 불가 -> 콘솔에 물리적인 접근 (물리서버)

3. **복구 머신** 사용
다른 시스템 이미지로 부팅한 후 문제가 있는 시스템의 파일 시스템을 디버깅 서버에
마운트 하여 상황
-> 클라우드 환경
-> (대안) EC2 직렬 콘솔 접근 이용



## 부팅 실행 서비스 만들기
![[Pasted image 20221011202047.png]]
![[Pasted image 20221011202108.png]]

